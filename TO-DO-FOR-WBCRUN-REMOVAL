go over all copyright notices in wbc again, and make sure that:
 * copyright is assigned to stanford
 * license is lgplv3
 * there's a note about the origin copyright and bsd license

--------------------------------------------------

from wbcrun/test/CMakeLists.txt:

list (APPEND TEST_LIBS wbcrun wbcnet)

if (${WBCRUN_HAVE_MQUEUE})
  list (APPEND TEST_LIBS rt)
endif (${WBCRUN_HAVE_MQUEUE})

if (${WBCRUN_HAVE_XMLRPC})
  message (STATUS "Adding tests for XmlRpc++ dependent code")
  add_executable (test_directory_server test_directory_server.cpp TestDirectory.cpp)
  target_link_libraries (test_directory_server ${TEST_LIBS} XmlRpc)
endif (${WBCRUN_HAVE_XMLRPC})

--------------------------------------------------

resurrect tests/test_model_servo.cpp

--------------------------------------------------

resurrect the top-level Makefile (it still uses the old wbcnet layout,
too!)

--------------------------------------------------

go over the old commented-out message handling from ServoProcess.cpp:

  // // //   bool ServoImplementation::
  // // //   HandleServiceCall(wbcnet::msg::Service const & user_request,
  // // // 		    wbcnet::msg::Service & user_reply)
  // // //   {
  // // //     if (logger->isDebugEnabled()) {
  // // //       ostringstream msg;
  // // //       msg << "wbc::ServoImplementation::HandleServiceCall()\n";
  // // //       user_request.Dump(msg, "  ");
  // // //       LOG_DEBUG (logger, msg.str());
  // // //     }
    
  // // //     if ( ! m_directory)
  // // //       m_directory = new BehaviorDirectory(m_behavior, this);
    
  // // //     if (m_directory_dispatcher.Handle(*m_directory, user_request, user_reply)) {
  // // //       if (logger->isDebugEnabled()) {
  // // // 	ostringstream msg;
  // // // 	msg << "wbc::ServoImplementation::HandleServiceCall() dispatcher did it\n";
  // // // 	user_reply.Dump(msg, "  ");
  // // // 	LOG_DEBUG (logger, msg.str());
  // // //       }
  // // //       return true;
  // // //     }
  // // //     LOG_DEBUG (logger, "wbc::ServoImplementation::HandleServiceCall(): dispatcher did not take care of it");
    
  // // //     user_reply.InitReply(user_request);
    
  // // //     if (user_request.code.NElements() < 2) {
  // // //       user_reply.code[0] = wbcnet::SRV_MISSING_CODE;
  // // //       if (logger->isDebugEnabled()) {
  // // // 	ostringstream msg;
  // // // 	msg << "wbc::ServoImplementation::HandleServiceCall() MISSING_CODE\n";
  // // // 	user_reply.Dump(msg, "  ");
  // // // 	LOG_DEBUG (logger, msg.str());
  // // //       }
  // // //       return true;
  // // //     }
    
  // // //     if (user_request.code[0] != wbcnet::SRV_SERVO_DOMAIN) {
  // // //       LOG_WARN (logger,
  // // // 		"wbc::ServoImplementation::HandleServiceCall(): invalid user request domain "
  // // // 		<< (int) user_request.code[0] << " " << wbcnet::srv_domain_to_string(user_request.code[0])
  // // // 		<< " (servo only explicitly handles SRV_SERVO_DOMAIN), replying with INVALID_COMMAND");
  // // //       user_reply.code[0] = wbcnet::SRV_INVALID_COMMAND;
  // // //       return true;
  // // //     }
    
  // // //     switch (user_request.code[1]) {
      
  // // //     case wbcnet::SRV_GET_ACTUAL:
  // // //       SAIMatrixAPI data(m_joint_angles);
  // // //       data.appendHorizontally(m_joint_velocities);
  // // //       data.appendHorizontally(m_command_torques);
  // // //       user_reply.matrix.Copy(data);
  // // //       user_reply.code[0] = wbcnet::SRV_SUCCESS;
  // // //       if (logger->isDebugEnabled()) {
  // // // 	ostringstream msg;
  // // // 	msg << "wbc::ServoImplementation::HandleServiceCall() GET_ACTUAL SUCCESS\n";
  // // // 	user_reply.Dump(msg, "  ");
  // // // 	LOG_DEBUG (logger, msg.str());
  // // //       }
  // // //       return true;
      
  // // //       ////
  // // //       //// XXXX to do: resurrect GET_END_POS command
  // // //       ////
  // // //       //     case wbcnet::SRV_GET_END_POS:
  // // //       //       if ( ! m_end_effector) {
  // // //       // 	user_reply.code[0] = wbcnet::SRV_OTHER_ERROR;
  // // //       // 	LOG_ERROR (logger, "wbc::ServoImplementation::HandleServiceCall(): GET_END_POS without end effector");
  // // //       // 	if (logger->isDebugEnabled()) {
  // // //       // 	  ostringstream msg;
  // // //       // 	  msg << "wbc::ServoImplementation::HandleServiceCall() OTHER_ERROR\n";
  // // //       // 	  user_reply.Dump(msg, "  ");
  // // //       // 	  LOG_DEBUG (logger, msg.str());
  // // //       // 	}
  // // //       // 	return true;
  // // //       //       }
  // // //       //       {
  // // //       // 	SAITransform const transform(m_kinematics->globalFrame(m_end_effector, nullVector));
  // // //       // 	SAIVectorAPI reply(transform.rotation().vecForm());
  // // //       // 	reply.append(transform.translation());
  // // //       // 	user_reply.matrix.Copy(reply);
  // // //       //       }
  // // //       //       user_reply.code[0] = wbcnet::SRV_SUCCESS;
  // // //       //       if (logger->isDebugEnabled()) {
  // // //       // 	ostringstream msg;
  // // //       // 	msg << "wbc::ServoImplementation::HandleServiceCall() GET_END_POS SUCCESS\n";
  // // //       // 	user_reply.Dump(msg, "  ");
  // // //       // 	LOG_DEBUG (logger, msg.str());
  // // //       //       }
  // // //       //       return true;
      
  // // //     case wbcnet::SRV_TOGGLE_RECORDER:
  // // //       Recorder::FlushAll();
  // // //       user_reply.code[0] = wbcnet::SRV_SUCCESS;
  // // //       if (logger->isDebugEnabled()) {
  // // // 	ostringstream msg;
  // // // 	msg << "wbc::ServoImplementation::HandleServiceCall() TOGGLE_RECORDER SUCCESS\n";
  // // // 	user_reply.Dump(msg, "  ");
  // // // 	LOG_DEBUG (logger, msg.str());
  // // //       }
  // // //       return true;
      
  // // //     default:
  // // //       if (m_current_behavior) {
  // // // 	LOG_DEBUG (logger,
  // // // 		   "wbc::ServoImplementation::HandleServiceCall(): forwarding " << (int) user_request.code[0]
  // // // 		   << " " << wbcnet::SRV_get_id_str(user_request.code[0]) << " to behavior "
  // // // 		   << m_current_behavior->name);
  // // // 	user_reply.code.SetNElements(1);
  // // // 	user_reply.matrix.SetSize(0, 0);

  // // // #error wtf

  // // // 	user_reply.code[0] = m_current_behavior->handleCommand(user_request.code.ElementPointer(),
  // // // 							       user_request.nCodes,
  // // // 							       SAIMatrixAPI(user_request.matrix));
  // // //       }
  // // //       else {
  // // // 	LOG_WARN (logger,
  // // // 		  "wbc::ServoImplementation::HandleServiceCall(): cannot forward " << (int) user_request.code[0]
  // // // 		  << " " << wbcnet::SRV_get_id_str(user_request.code[0]) << " (no current behavior)");
  // // // 	user_reply.code.SetNElements(1);
  // // // 	user_reply.matrix.SetSize(0, 0);
  // // // 	user_reply.code[0] = wbcnet::SRV_TRY_AGAIN;
  // // //       }
  // // //       if (logger->isDebugEnabled()) {
  // // // 	ostringstream msg;
  // // // 	msg << "wbc::ServoImplementation::HandleServiceCall(): reply from behavior\n";
  // // // 	user_reply.Dump(msg, "  ");
  // // // 	LOG_DEBUG (logger, msg.str());
  // // //       }
  // // //       return true;
      
  // // //     }
    
  // // //     LOG_WARN (logger, "wbc::ServoImplementation::HandleServiceCall(): BUG? reached end of switch");
  // // //     return false;		// never happens though
  // // //   }
  
  
--------------------------------------------------
